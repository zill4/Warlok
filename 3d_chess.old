from enum import Enum
from ursina import *
from ursina.prefabs.first_person_controller import FirstPersonController
from ursina.shaders import lit_with_shadows_shader, basic_lighting_shader
from random import uniform, randint
import os
from abc import ABC, abstractmethod
from src.constants import *
from src.models import piece_models
from src.entities import (
    GameEntity,
    ChessPiece,
    piece_classes,
    CardBase,
    CardEntity
)
from src.game.state import CardState
from src.game.rules import GameRules
from src.game.ui import create_card_ui, update_cards, update_cards_for_turn

app = Ursina()
window.title = '3D Chess'
window.color = color.black  # Set background color to black

# Add this at the top level (right after app = Ursina())
piece_entities = []
card_entities = []  # Initialize empty list for card entities

# Add at top level
VIRTUAL_GRID = [[None for _ in range(8)] for _ in range(8)]

# Add at top level with other globals
selected_piece = None
selected_card = None

# Board dimensions
class Board:
    SIZE = 8
    ROWS = range(SIZE)
    COLS = range(SIZE)
    MAX_INDEX = SIZE - 1  # 7 for coordinate conversion
    THICKNESS = 0.1  # Board square height

# Camera constants
class Camera:
    PIVOT_HEIGHT = 12  # Lower height
    START_HEIGHT = 3  # Lower camera position
    START_DISTANCE = -25  # Not as far back
    START_ROTATION = 25  # Less steep angle
    WHITE_ROTATION_Y = 180
    BLACK_ROTATION_Y = 0
    ROTATION_SMOOTHING = 8
    MOUSE_SENSITIVITY = 40
    MIN_ROTATION_X = 15
    MAX_ROTATION_X = 70

# Piece position constants
class Position:
    GROUND_HEIGHT = 0.2  # Reduced from 0.5 to 0.2 for base piece height
    HOVER_HEIGHT = 0.4   # Reduced from 0.8 to 0.4 for hover effect
    SELECTED_HEIGHT = 0.6  # Reduced from 1.0 to 0.6 for selected pieces
    HOVER_X_THRESHOLD = 0.3
    HOVER_Z_THRESHOLD = 0.1
    MARKER_SCALE = 0.3
    MARKER_HEIGHT = Board.THICKNESS * 1.5  # Reduced multiplier for markers

# Board colors
class BoardColors:
    WHITE = color.white
    BLACK = color.gray
    HOVER = color.green

# Player turns
class Turn(Enum):
    WHITE = "white"
    BLACK = "black"

# Starting rows for pieces
class PieceRows:
    BLACK_BACK = Board.MAX_INDEX
    BLACK_PAWN = Board.MAX_INDEX - 1
    WHITE_PAWN = 1
    WHITE_BACK = 0

# Piece scale factors (original values divided by 4)
class PieceScale:
    PAWN = 0.00375
    ROOK = 0.005
    KNIGHT = 0.0045
    BISHOP = 0.005
    QUEEN = 0.00625
    KING = 0.0075

# Light position
class Light:
    HEIGHT = 2
    DISTANCE = 3
    ROTATION = (45, -45, 45)
    INTENSITY = 1.0

# Board center for camera
class BoardCenter:
    X = (Board.SIZE - 1) / 2  # 3.5
    Z = (Board.SIZE - 1) / 2  # 3.5

# Piece rotation
class PieceRotation:
    WHITE = (0, 0, 0)
    BLACK = (0, 180, 0)

# Add to color constants
class PieceColors:
    WHITE = color.white
    BLACK = color.red  # Current red for black pieces
    WHITE_HIGHLIGHT = color.azure  # Light blue highlight for white
    BLACK_HIGHLIGHT = color.orange  # Orange highlight for black
    SELECTED_WHITE = color.cyan  # For selected white piece
    SELECTED_BLACK = color.yellow  # For selected black piece

# Add to your constants section
class CardUI:
    CARD_WIDTH = 0.1
    CARD_HEIGHT = 0.15
    CARD_SPACING = 0.08  # Reduced from 0.11 to create overlap
    BOTTOM_MARGIN = -0.35
    CARD_TEXTURE = './images/Normal_card.png'
    MAX_CARDS = 8
    # 3D effect constants
    MAX_ROTATION = 3
    STACK_HEIGHT = 0.001
    POSITION_VARIANCE = 0.002
    # Deck appearance constants
    DECK_CARDS = 30          # Increased number of visible cards
    DECK_SPACING = 0.0003    # Tighter spacing between cards
    DECK_SIDE_WIDTH = 0.01
    DECK_EXTRA_SPACING = 0.15  # Additional spacing between hand and deck
    HOVER_LIFT = 0.05       # How high the card lifts on hover
    HOVER_FORWARD = -0.05   # How far forward (towards screen) the card moves
    HOVER_SEPARATION = 0.03 # How far the card separates from others
    HAND_HEIGHT = 0.5        # Height above ground for cards in hand
    HAND_DISTANCE = 2        # Distance from board edge
    CARD_ROTATION = (60, 0, 0)  # Make cards stand more upright

class PlayerCards:
    WHITE = {
        'dragon_image': './images/blue_eyes_w_dragon.png',
        'deck_color': color.blue,
        'hand': [],
        'deck': [],
        'played': []
    }
    BLACK = {
        'dragon_image': './images/RedEyesBDragon.jpg',
        'deck_color': color.red,
        'hand': [],
        'deck': [],
        'played': []
    }

class CardState:
    def __init__(self):
        self.current_player = 'WHITE'
        self.max_hand_size = 7  # Fixed hand size
        self.white_cards = {
            'hand': [],  # List of actual card entities
            'deck': [True] * 40,  # Cards remaining in deck
            'played': []  # Cards that have been used
        }
        self.black_cards = {
            'hand': [],
            'deck': [True] * 40,
            'played': []
        }
        print("Card state initialized")
        
        # Initialize starting hands
        self.deal_initial_hands()
    
    def deal_initial_hands(self):
        """Deal initial hands to both players"""
        # Deal to white player
        self.current_player = 'WHITE'
        for _ in range(5):  # Start with 5 cards
            self.draw_card()
            
        # Deal to black player
        self.current_player = 'BLACK'
        for _ in range(5):  # Start with 5 cards
            self.draw_card()
            
        # Reset to white player's turn
        self.current_player = 'WHITE'
        print("Initial hands dealt")
    
    def switch_turn(self):
        """Switch turns and draw a card for the new player"""
        self.current_player = 'BLACK' if self.current_player == 'WHITE' else 'WHITE'
        # Draw a card for the new player if their hand isn't full
        self.draw_card()
        return self.get_current_player_data()
    
    def get_current_player_data(self):
        return PlayerCards.BLACK if self.current_player == 'BLACK' else PlayerCards.WHITE
    
    def draw_card(self):
        """Draw a card if hand isn't full"""
        cards = self.black_cards if self.current_player == 'BLACK' else self.white_cards
        
        if len(cards['hand']) >= self.max_hand_size:
            print(f"{self.current_player}'s hand is full")
            return None
            
        # Check if there are cards in the deck
        if not any(cards['deck']):
            print(f"{self.current_player}'s deck is empty")
            return None
            
        # Find first available card in deck
        for i, card in enumerate(cards['deck']):
            if card:
                cards['deck'][i] = False  # Remove from deck
                print(f"{self.current_player} drew a card")
                # Create the card UI
                new_card = create_card_ui(self)
                if new_card:
                    cards['hand'].append(new_card)
                return True
        return None
    
    def remove_card_from_hand(self, card_entity):
        """Remove a card after it's played"""
        cards = self.black_cards if self.current_player == 'BLACK' else self.white_cards
        if card_entity in cards['hand']:
            cards['hand'].remove(card_entity)
            cards['played'].append(card_entity)
            print(f"Card removed from {self.current_player}'s hand")
            return True
        return False

# First, define the base classes
class GameEntity(ABC):
    def __init__(self, is_black, grid_x, grid_z):
        self.is_black = is_black
        self.grid_x = grid_x
        self.grid_z = grid_z
        self.original_color = None
        self.valid_moves = []
        self.valid_move_markers = []

    @abstractmethod
    def get_valid_moves(self, grid):
        pass

# Then define CardBase before CardEntity
class CardBase(GameEntity):
    def __init__(self, is_black, grid_x, grid_z, symbol):
        super().__init__(is_black, grid_x, grid_z)
        self.symbol = symbol
        self.is_card = True
        self.card_texture = None
        self.piece_type = None  # The type of chess piece this card represents
    
    def get_valid_moves(self, grid):
        """Implement abstract method from GameEntity"""
        # Cards don't move on the board, so return empty list
        return []
        
    def create_piece_entity(self):
        """Factory method to create the corresponding chess piece"""
        if self.piece_type not in piece_classes:
            raise ValueError(f"Invalid piece type: {self.piece_type}")
            
        return piece_classes[self.piece_type](
            is_black=self.is_black,
            grid_x=self.grid_x,
            grid_z=self.grid_z,
            model=load_model(piece_models[self.piece_type]['black' if self.is_black else 'white']),
            scale=piece_models[self.piece_type]['scale'],
            rotation=PieceRotation.BLACK if self.is_black else PieceRotation.WHITE,
            position=(self.grid_x, Position.GROUND_HEIGHT, self.grid_z),
            shader=basic_lighting_shader,
            double_sided=True,
        )

# Now we can define CardEntity which uses CardBase
class CardEntity:
    def __init__(self, parent, card_data: CardBase, image, index, original_position, original_z, is_hovered=False):
        self.card_data = card_data
        self.parent = parent
        self.image = image
        self.index = index
        # Convert original_position to Vec3 if it's not already
        if isinstance(original_position, (int, float)):
            self.original_position = Vec3(original_position, CardUI.HAND_HEIGHT, BoardCenter.Z + CardUI.HAND_DISTANCE)
        else:
            self.original_position = Vec3(original_position) if not isinstance(original_position, Vec3) else original_position
        
        self.original_z = original_z
        self.is_hovered = is_hovered
        self.is_selected = False
        
        # Set initial position and rotation
        self.parent.position = self.original_position
        self.parent.rotation = CardUI.CARD_ROTATION

    def hover(self):
        if not self.is_hovered and not self.is_selected:  # Don't hover if selected
            self.is_hovered = True
            # Convert original_position to Vec3 if it isn't already
            target_pos = Vec3(self.original_position) + Vec3(0, CardUI.HOVER_LIFT, CardUI.HOVER_FORWARD)
            self.parent.animate_position(
                target_pos,
                duration=0.1
            )
            self._adjust_adjacent_cards(True)
    
    def unhover(self):
        if self.is_hovered and not self.is_selected:  # Don't unhover if selected
            self.is_hovered = False
            # Ensure original_position is Vec3
            target_pos = Vec3(self.original_position)
            self.parent.animate_position(
                target_pos,
                duration=0.1
            )
            self._adjust_adjacent_cards(False)
    
    def _adjust_adjacent_cards(self, hovering):
        """Adjust positions of adjacent cards"""
        if not card_entities:
            return
        
        try:
            separation = CardUI.HOVER_SEPARATION if hovering else 0
            
            # Only adjust left card if we're not the first card
            if self.index > 0 and self.index - 1 < len(card_entities):
                left_card = card_entities[self.index - 1]
                left_target = Vec3(left_card.original_position)
                if hovering:
                    left_target += Vec3(-separation, 0, 0)
                left_card.parent.animate_position(left_target, duration=0.1)
            
            # Only adjust right card if we're not the last card
            if self.index < len(card_entities) - 1:
                right_card = card_entities[self.index + 1]
                right_target = Vec3(right_card.original_position)
                if hovering:
                    right_target += Vec3(separation, 0, 0)
                right_card.parent.animate_position(right_target, duration=0.1)
                    
        except Exception as e:
            print(f"Error in _adjust_adjacent_cards: {e}")
    
    def select_card(self):
        global selected_card
        self.is_selected = True
        selected_card = self
        # Lift card higher to show it's selected
        self.parent.animate_position(
            self.original_position + Vec3(0, CardUI.HOVER_LIFT * 2, CardUI.HOVER_FORWARD),
            duration=0.1
        )
        print("Card selected")
    
    def place_on_board(self, grid_x, grid_z):
        """Replace this card with the corresponding chess piece"""
        try:
            # Create the actual chess piece
            piece = self.card_data.create_piece_entity()
            
            # Update virtual grid
            VIRTUAL_GRID[grid_z][grid_x] = piece
            piece_entities.append(piece)
            
            # Remove card from UI and game state
            if self in card_entities:
                card_entities.remove(self)
            destroy(self.parent)
            
            return True
        except Exception as e:
            print(f"Error placing card: {e}")
            return False

# Modified ChessPiece to inherit from GameEntity
class ChessPiece(GameEntity):
    def __init__(self, is_black, grid_x, grid_z, **kwargs):
        super().__init__(is_black, grid_x, grid_z)
        self.original_color = PieceColors.BLACK if is_black else PieceColors.WHITE
        self.color = self.original_color
        self.original_y = Position.GROUND_HEIGHT
    
    def highlight(self):
        """Highlight piece when hovered"""
        if self.is_black:
            self.color = PieceColors.BLACK_HIGHLIGHT
        else:
            self.color = PieceColors.WHITE_HIGHLIGHT
    
    def reset_color(self):
        """Reset piece to original color"""
        self.color = self.original_color
    
    def select(self):
        """Highlight piece when selected"""
        if self.is_black:
            self.color = PieceColors.SELECTED_BLACK
        else:
            self.color = PieceColors.SELECTED_WHITE
    
    def update_visual_position(self):
        """Update the piece's visual position based on grid coordinates"""
        self.position = Vec3(self.grid_x, self.y, self.grid_z)
    
    def show_valid_moves(self, valid_moves):
        """Show markers for valid moves"""
        self.valid_moves = valid_moves
        self.clear_markers()
        
        for x, z in valid_moves:
            marker = Entity(
                model='sphere',
                color=color.rgba(0, 1, 0, 0.5),
                position=(x, Position.MARKER_HEIGHT, z),
                scale=Position.MARKER_SCALE
            )
            self.valid_move_markers.append(marker)
    
    def clear_markers(self):
        """Clear all valid move markers"""
        for marker in self.valid_move_moves:
            destroy(marker)
        self.valid_move_markers.clear()

    def update(self):
        """Handle hover highlighting"""
        if mouse.hovered_entity == self:
            self.highlight()
        else:
            self.reset_color()

class Pawn(ChessPiece):
    def get_valid_moves(self, grid):
        valid = []
        direction = 1 if self.is_black else -1  # Fix direction: white moves up (-z), black moves down (+z)
        new_z = self.grid_z + direction
        
        # Forward move one space
        if 0 <= new_z < Board.SIZE and not grid[new_z][self.grid_x]:
            valid.append((self.grid_x, new_z))
            
            # First move can be two spaces if path is clear
            if (self.is_black and self.grid_z == 1) or (not self.is_black and self.grid_z == 6):  # Starting positions
                two_spaces_z = new_z + direction  # One more space in same direction
                if 0 <= two_spaces_z < Board.SIZE and not grid[two_spaces_z][self.grid_x]:
                    valid.append((self.grid_x, two_spaces_z))
        
        # Captures
        for dx in [-1, 1]:
            new_x = self.grid_x + dx
            if 0 <= new_x < Board.SIZE and 0 <= new_z < Board.SIZE:
                target = grid[new_z][new_x]
                if target and target.is_black != self.is_black:
                    valid.append((new_x, new_z))
        
        return valid

class Rook(ChessPiece):
    def get_valid_moves(self, board_state):
        valid_positions = []
        x, z = int(self.grid_x), int(self.grid_z)
        
        # Horizontal and vertical moves
        for dx, dz in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            curr_x, curr_z = x, z
            while True:
                curr_x, curr_z = curr_x + dx, curr_z + dz
                if not (0 <= curr_x < Board.SIZE and 0 <= curr_z < Board.SIZE):
                    break
                
                target = board_state[curr_z][curr_x]
                valid_positions.append((curr_x, curr_z))
                if target:  # Stop if we hit a piece (after adding the position for capture)
                    break
        
        print(f"Rook at ({x}, {z}) valid moves: {valid_positions}")
        return valid_positions

class Knight(ChessPiece):
    def get_valid_moves(self, board_state):
        valid_positions = []
        x, z = int(self.grid_x), int(self.grid_z)
        
        moves = [
            (1, 2), (2, 1), (2, -1), (1, -2),
            (-1, -2), (-2, -1), (-2, 1), (-1, 2)
        ]
        for dx, dz in moves:
            new_x, new_z = x + dx, z + dz
            if 0 <= new_x < Board.SIZE and 0 <= new_z < Board.SIZE:
                target = board_state[new_z][new_x]
                if not target or target.is_black != self.is_black:
                    valid_positions.append((new_x, new_z))
        
        print(f"Knight at ({x}, {z}) valid moves: {valid_positions}")
        return valid_positions

class Bishop(ChessPiece):
    def get_valid_moves(self, board_state):
        valid_positions = []
        x, z = int(self.grid_x), int(self.grid_z)
        
        # Diagonal moves
        for dx, dz in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
            curr_x, curr_z = x, z
            while True:
                curr_x, curr_z = curr_x + dx, curr_z + dz
                if not (0 <= curr_x < Board.SIZE and 0 <= curr_z < Board.SIZE):
                    break
                
                target = board_state[curr_z][curr_x]
                valid_positions.append((curr_x, curr_z))
                if target:  # Stop if we hit a piece (after adding the position for capture)
                    break
        
        print(f"Bishop at ({x}, {z}) valid moves: {valid_positions}")
        return valid_positions

class Queen(ChessPiece):
    def get_valid_moves(self, board_state):
        valid_positions = []
        x, z = int(self.grid_x), int(self.grid_z)
        
        # Combine rook and bishop moves
        directions = [
            (0, 1), (0, -1), (1, 0), (-1, 0),  # Rook moves
            (1, 1), (1, -1), (-1, 1), (-1, -1)  # Bishop moves
        ]
        
        for dx, dz in directions:
            curr_x, curr_z = x, z
            while True:
                curr_x, curr_z = curr_x + dx, curr_z + dz
                if not (0 <= curr_x < Board.SIZE and 0 <= curr_z < Board.SIZE):
                    break
                
                target = board_state[curr_z][curr_x]
                valid_positions.append((curr_x, curr_z))
                if target:  # Stop if we hit a piece (after adding the position for capture)
                    break
        
        print(f"Queen at ({x}, {z}) valid moves: {valid_positions}")
        return valid_positions

class King(ChessPiece):
    def get_valid_moves(self, board_state):
        valid_positions = []
        x, z = int(self.grid_x), int(self.grid_z)
        
        # All adjacent squares
        directions = [
            (0, 1), (0, -1), (1, 0), (-1, 0),  # Orthogonal
            (1, 1), (1, -1), (-1, 1), (-1, -1)  # Diagonal
        ]
        
        for dx, dz in directions:
            new_x, new_z = x + dx, z + dz
            if 0 <= new_x < Board.SIZE and 0 <= new_z < Board.SIZE:
                target = board_state[new_z][new_x]
                if not target or target.is_black != self.is_black:
                    valid_positions.append((new_x, new_z))
        
        print(f"King at ({x}, {z}) valid moves: {valid_positions}")
        return valid_positions

# Then define the piece_classes dictionary AFTER all classes are defined
piece_classes = {
    'pawn': Pawn,
    'rook': Rook,
    'knight': Knight,
    'bishop': Bishop,
    'queen': Queen,
    'king': King
}

# Finally define specific card types
class PawnCard(CardBase):
    def __init__(self, is_black, grid_x, grid_z, symbol):
        super().__init__(is_black, grid_x, grid_z, symbol)
        self.piece_type = 'pawn'

class KnightCard(CardBase):
    def __init__(self, is_black, grid_x, grid_z, symbol):
        super().__init__(is_black, grid_x, grid_z, symbol)
        self.piece_type = 'knight'

# ... add other card types ...

# Update piece creation to use factory method
def create_piece_at_position(piece_type, grid_x, grid_z):
    # Create temporary card to generate piece
    temp_card = CardBase(is_black=(grid_z >= Board.SIZE/2), 
                       grid_x=grid_x, grid_z=grid_z, symbol=None)
    temp_card.piece_type = piece_type
    return temp_card.create_piece_entity()

class ChessSymbols:
    TEXTURE = './images/chess_symbols.png'
    SPRITE_COUNT = 7
    UV_WIDTH = 1/7  # Each piece takes 1/7 of the width
    UV_HEIGHT = 0.5  # Each row takes half the height
    SYMBOL_SCALE = 0.025  # Made slightly smaller
    
    @staticmethod
    def get_random_symbol_uvs(is_black=False):
        piece_index = randint(0, ChessSymbols.SPRITE_COUNT - 1)
        # Calculate UV coordinates
        u = piece_index * ChessSymbols.UV_WIDTH
        v = 0.5 if not is_black else 0
        return {
            'offset': Vec2(u, v),
            'scale': Vec2(ChessSymbols.UV_WIDTH, ChessSymbols.UV_HEIGHT)
        }

class GameRules:
    def __init__(self, card_state, camera_pivot):
        self.card_state = card_state
        self.camera_pivot = camera_pivot
        self.camera_rotation_x = Camera.START_ROTATION
        self.camera_rotation_y = Camera.WHITE_ROTATION_Y
        self.manual_control = False

    def update_camera(self):
        """Handle camera rotation while maintaining manual control"""
        # Automatic rotation when not manually controlled
        if not self.manual_control:
            # Target rotation based on current player
            target_rotation_y = Camera.BLACK_ROTATION_Y if self.card_state.current_player == 'BLACK' else Camera.WHITE_ROTATION_Y
            target_rotation_x = Camera.START_ROTATION
            
            # Smoothly interpolate towards target
            self.camera_rotation_x = lerp(self.camera_rotation_x, target_rotation_x, time.dt * Camera.ROTATION_SMOOTHING)
            self.camera_rotation_y = lerp(self.camera_rotation_y, target_rotation_y, time.dt * Camera.ROTATION_SMOOTHING)

        # Middle mouse drag manual control
        if mouse.middle:
            self.manual_control = True
            self.camera_rotation_x -= mouse.velocity[1] * Camera.MOUSE_SENSITIVITY
            self.camera_rotation_x = clamp(self.camera_rotation_x, Camera.MIN_ROTATION_X, Camera.MAX_ROTATION_X)
            self.camera_rotation_y += mouse.velocity[0] * Camera.MOUSE_SENSITIVITY

        # Directly set rotation without lerp when manual control is active
        self.camera_pivot.rotation = (
            self.camera_rotation_x,
            self.camera_rotation_y,
            0
        )

    def setup_camera(self):
        """Initialize camera settings with better view of board"""
        camera.parent = self.camera_pivot
        self.camera_pivot.position = (BoardCenter.X, Camera.PIVOT_HEIGHT, BoardCenter.Z)
        camera.position = (0, Camera.START_HEIGHT, Camera.START_DISTANCE)
        camera.rotation_x = Camera.START_ROTATION
        self.camera_pivot.rotation_y = Camera.WHITE_ROTATION_Y

class InitialSetup:
    WHITE_KING_POS = (4, 0)  # e1
    BLACK_KING_POS = (4, 7)  # e8
    # Define starting positions for all pieces
    PIECE_POSITIONS = [
        ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],  # Black back row
        ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],          # Black pawns
        [None, None, None, None, None, None, None, None],
        [None, None, None, None, None, None, None, None],
        [None, None, None, None, None, None, None, None],
        [None, None, None, None, None, None, None, None],
        ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],          # White pawns
        ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],  # White back row
    ]

# Add near the top with other constants
piece_models = {
    'pawn': {
        'white': './models/pawn_white.obj',
        'black': './models/pawn_black.obj',
        'scale': PieceScale.PAWN
    },
    'rook': {
        'white': './models/rook_white.obj',
        'black': './models/rook_black.obj',
        'scale': PieceScale.ROOK
    },
    'knight': {
        'white': './models/knight_white.obj',
        'black': './models/knight_black.obj',
        'scale': PieceScale.KNIGHT
    },
    'bishop': {
        'white': './models/bishop_white.obj',
        'black': './models/bishop_black.obj',
        'scale': PieceScale.BISHOP
    },
    'queen': {
        'white': './models/queen_white.obj',
        'black': './models/queen_black.obj',
        'scale': PieceScale.QUEEN
    },
    'king': {
        'white': './models/king_white.obj',
        'black': './models/king_black.obj',
        'scale': PieceScale.KING
    }
}

def create_board():
    """Create the chess board"""
    board_parent = Entity()
    
    # Create board squares with more visible colors
    for row in Board.ROWS:
        for col in Board.COLS:
            is_white = (row + col) % 2 == 0
            Entity(
                parent=board_parent,
                model='cube',  # Changed from 'quad' to 'cube' for better visibility
                scale=(1, Board.THICKNESS, 1),
                position=(col, 0, row),
                color=BoardColors.WHITE if is_white else BoardColors.BLACK,
                shader=lit_with_shadows_shader
            )
    
    return board_parent

def create_pieces():
    """Create all chess pieces"""
    pieces_parent = Entity()
    
    # Create pieces based on initial positions
    for row in Board.ROWS:
        for col in Board.COLS:
            piece_type = InitialSetup.PIECE_POSITIONS[row][col]  # Use InitialSetup directly
            if piece_type:
                is_black = row < 4  # Top half is black pieces
                
                piece = piece_classes[piece_type](
                    is_black=is_black,
                    grid_x=col,
                    grid_z=row,
                    model=load_model(piece_models[piece_type]['black' if is_black else 'white']),
                    scale=piece_models[piece_type]['scale'],
                    rotation=PieceRotation.BLACK if is_black else PieceRotation.WHITE,
                    position=(col, Position.GROUND_HEIGHT, row),
                    shader=basic_lighting_shader,
                    double_sided=True
                )
                
                VIRTUAL_GRID[row][col] = piece
                piece_entities.append(piece)
    
    return pieces_parent

def start_game():
    global piece_entities, card_entities, selected_card
    selected_card = None
    
    # Clear any existing entities
    for entity in scene.entities:
        destroy(entity)
    
    # Reset piece_entities and card_entities lists
    piece_entities.clear()
    card_entities.clear()
    
    # Initialize card state
    card_state = CardState()
    
    # Create camera pivot
    camera_pivot = Entity()
    
    # Initialize game rules with camera pivot
    game_rules = GameRules(card_state, camera_pivot)
    game_rules.setup_camera()
    
    # Create board and pieces
    board = create_board()
    pieces = create_pieces()
    
    # Create update function
    def update():
        game_rules.update_camera()  # Make sure this is called every frame
        update_cards()
    
    # Connect the update function to the game
    app.update = update  # This line is crucial!
    
    return game_rules, card_state

def exit_game():
    application.quit()

def create_menu():
    # Create a parent entity for menu items
    menu = Entity(parent=camera.ui)
    
    # Title text
    Text("3D Chess", parent=menu, y=0.3, x=0, origin=(0,0), scale=3)
    
    # Start button
    Button(text="Start Game", 
           parent=menu,
           y=0, 
           x=0,
           scale=(0.3, 0.1),
           color=color.azure,
           highlight_color=color.gray[2],
           pressed_color=color.blue,
           on_click=start_game)
    
    # Exit button
    Button(text="Exit", 
           parent=menu,
           y=-0.15, 
           x=0,
           scale=(0.3, 0.1),
           color=color.red,
           highlight_color=color.gray[2],
           pressed_color=color.red,
           on_click=exit_game)

# Create the main menu when the game starts
create_menu()

def input(key):
    if key == 'k':  # Press K to kill first black piece
        # Add safety check
        if not piece_entities:
            return
            
        for p in piece_entities:
            if p.is_black:
                destroy(p)
                piece_entities.remove(p)
                break

def update_cards_for_turn(cards, deck_cards, card_state):
    """Update card images and deck color based on turn"""
    player_data = card_state.get_current_player_data()
    is_black_turn = player_data == PlayerCards.BLACK
    
    # Update all card images and symbols
    for _, card_image, symbol in cards:
        card_image.texture = player_data['dragon_image']
        # Update symbol UVs for current turn
        uvs = ChessSymbols.get_random_symbol_uvs(is_black_turn)
        symbol.texture_scale = uvs['scale']
        symbol.texture_offset = uvs['offset']
    
    # Update deck appearance
    base_color = player_data['deck_color']
    for deck_card in deck_cards:
        deck_card.color = base_color

# Start the game
game_rules, card_state = start_game()

# Run the game
app.run() 